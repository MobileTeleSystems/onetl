### --------------- List of tags that are used to select a runner. --------------- ###
## Обязательный блок для запуска gitlab-ci. Определяет, на каких runner-ах будет запущен CI/CD путем выбора его с помощью tag'а. ##

default:
  tags:
  - bigdata
  - dmz
  - docker

### --------------- Defines a job stage. --------------- ###
## Stage .pre выполняется перед всем остальным кодом. stage .post выполняется после всего остального кода. ##
## Так же можо задать порядок выполнения stage-ов, указав их по порядку в этом блоке. ##

stages:
#- pre-commit
- static analysis
- build
- tests
- sonarqube_check
- build_docs
- artifactory
- deploy

### --------------- Include gitlab-ci-templates --------------- ###
## Добавляет в текущую конфигурацию CI\CD template's из DevOps репозитория для переиспользования. ##

include:
# VAULT
- project: DevOps/cicd-store/gitlabci/vault
  ref: v3
  file: .base_devops_get_cicd_secrets.yml

# DOCKER
- project: DevOps/cicd-store/gitlabci/docker
  ref: v6
  file:
  - .base_docker_build.yml
  - .base_docker_cleaner.yml

# SONARQUBE
- project: DevOps/cicd-store/gitlabci/sonarqube
  ref: v1
  file: .base_check_sonarqube.yml

# PIP BUILD AND DEPLOY TO JFROG
- project: DevOps/cicd-store/gitlabci/pip
  ref: v2
  file: .base_pip_pkg_build_and_deploy_to_jfrog.yml

# Pages
- project: DevOps/cicd-store/gitlabci/pages
  ref: v1
  file: .base_pages_deploy_sphinx.yml

# Artifactory
- project: DevOps/cicd-store/gitlabci/artifactory
  ref: v3
  file:
  - .base_rt_upload.yml
  - .base_rt_cli.yml

### --------------- Workflow rules --------------- ###
workflow:
  rules:
  - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    when: never
  # do not run anything on push commit to master branch, tests and linters have already executed on develop branch
  - if: $CI_COMMIT_BRANCH =~ /^(master|main)$/
    when: never
  - when: always

### --------------- Get VAULT SECRET --------------- ###
## Переиспользование добавленного template'а по добавлению SSH-ключа пользователя ansible. ##
devops_get_cicd_secrets:
  extends: .base_devops_get_cicd_secrets
  interruptible: true

# TODO: сделать в отдельной задаче
#pre-commit:
#  image: $CI_REGISTRY/platform/python:${PYTHON_VERSION}
#  variables:
#    PYTHON_VERSION: '3.7'
#  stage: pre-commit
#  script:
#  - yum install -y git
#  - pip install pre-commit
#  - pre-commit run --all-files

mypy:
  image: $CI_REGISTRY/platform/python:${PYTHON_VERSION}
  variables:
    PYTHON_VERSION: '3.7'
  stage: static analysis
  script:
  - pip install mypy types-PyYAML types-Deprecated
  - python3 -m mypy --config-file setup.cfg onetl
  rules:
  # do not run linters after pushing git tag, code was already linted
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success
  interruptible: true

flake8:
  image: $CI_REGISTRY/platform/python:${PYTHON_VERSION}
  variables:
    PYTHON_VERSION: '3.7'
  stage: static analysis
  script:
  - pip install wemake-python-styleguide
  - python3 -m flake8 --format=default . 2>&1 | tee flake8.txt
  artifacts:
    when: always
    paths: [flake8.txt]
  rules:
  # do not run linters after pushing git tag, code was already linted
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success
  interruptible: true

black:
  image: $CI_REGISTRY/platform/python:${PYTHON_VERSION}
  variables:
    PYTHON_VERSION: '3.7'
  stage: static analysis
  script:
  - pip install black
  - python3 -m black . --check
  rules:
  # do not run linters after pushing git tag, code was already linted
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success
  interruptible: true

.build_docker_images:
  extends: .base_docker_build
  stage: build
  variables:
    DOCKER_IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    STOP_IF_EXISTS: 'false'
  dependencies:
  - devops_get_cicd_secrets
  rules:
  # do not build docker images after pushing git tag, code was already tested
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success
  interruptible: true

build_docker_image:
  extends: .build_docker_images
  variables:
    DOCKER_BUILD_EXTRA_ARGS: --build-arg BUILD_NUMBER=$CI_PIPELINE_IID --build-arg BRANCH_NAME=$CI_COMMIT_BRANCH
    DOCKER_CACHE_FROM: ${CI_REGISTRY}/${CI_PROJECT_PATH}:develop
build_docker_image_webdav:
  extends: .build_docker_images
  variables:
    DOCKER_FILE_PATH: ./docker/webdav/Dockerfile
    DOCKER_IMAGE_NAME: ${CI_REGISTRY}/${CI_PROJECT_PATH}/webdav
build_docker_image_postgres:
  extends: .build_docker_images
  variables:
    DOCKER_FILE_PATH: ./docker/postgres/Dockerfile
    DOCKER_IMAGE_NAME: ${CI_REGISTRY}/${CI_PROJECT_PATH}/postgres
build_docker_image_oracle:
  extends: .build_docker_images
  variables:
    DOCKER_FILE_PATH: ./docker/oracle/Dockerfile
    DOCKER_IMAGE_NAME: ${CI_REGISTRY}/${CI_PROJECT_PATH}/oracle
build_docker_image_hive2:
  extends: .build_docker_images
  variables:
    DOCKER_FILE_PATH: ./docker/hive2/Dockerfile
    DOCKER_IMAGE_NAME: ${CI_REGISTRY}/${CI_PROJECT_PATH}/hive2

tests:
  image: ${CI_REGISTRY}/${CI_PROJECT_PATH}:${DOCKER_IMAGE_TAG}
  stage: tests
  variables:
    DOCKER_IMAGE_TAG: ${CI_COMMIT_REF_SLUG}
    # Postgres
    POSTGRES_USER: onetl
    POSTGRES_DB: onetl
    POSTGRES_HOST: postgres
    POSTGRES_PASSWORD: ohtae0luxeshi1uraeluMoh9IShah7ai
    # Oracle
    ORACLE_BASE: /opt/oracle
    ORACLE_HOME: /opt/oracle/product/18c/dbhomeXE
    ORACLE_SID: XE
    ORACLE_ALLOW_REMOTE: 'true'
    # MySQL
    MYSQL_ROOT_PASSWORD: ohbuz9Eochaj9saibooK3thooGa5aesh
    MYSQL_DATABASE: onetl
    MYSQL_USER: onetl
    MYSQL_PASSWORD: ohbuz9Eochaj9saibooK3thooGa5aesh
    MYSQL_HOST: mysql
    MYSQL_TCP_PORT: '3306'
    # MSSQL
    MSSQL_DB: onetl
    MSSQL_USER: onetl
    MSSQL_PASSWORD: 7ellowEl7akey
    ACCEPT_EULA: Y
    SA_PASSWORD: 2astazeY
    # Hive
    TZ: Europe/Moscow
    # Minio
    MINIO_ROOT_USER: minio_admin
    MINIO_ROOT_PASSWORD: minio_password
    # WebDAV
    APP_USER_NAME: admin
    APP_USER_PASSWD: awd123fd1
    APP_UID: 1777
    APP_GID: 1777
    # Enables creation of a Docker network per build with the docker executor
    FF_NETWORK_PER_BUILD: 1
    # Test results files
    JUNIT_FILE: junitxml.xml
  rules:
  # do not run tests after pushing git tag, code was already tested
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success
  services:
  - name: ${CI_REGISTRY}/${CI_PROJECT_PATH}/webdav:${DOCKER_IMAGE_TAG}
    alias: webdav
  - name: ${CI_REGISTRY}/${CI_PROJECT_PATH}/postgres:${DOCKER_IMAGE_TAG}
    alias: postgres
  - name: ${CI_REGISTRY}/${CI_PROJECT_PATH}/hive2:${DOCKER_IMAGE_TAG}
    alias: hive2
  - name: yandex/clickhouse-server
    alias: clickhouse
  - name: ${CI_REGISTRY}/${CI_PROJECT_PATH}/oracle:${DOCKER_IMAGE_TAG}
    alias: oracle
  - name: mysql
    alias: mysql
  - name: mcmoe/mssqldocker
    alias: mssql
  - name: ${CI_REGISTRY}/datagrip/greenplum:6.8
    alias: greenplum
  - name: minio/minio
    alias: minio
    command: [server, /data]
  script:
  - coverage run --rcfile=tests/.coveragerc -m pytest tests/ --junitxml=${JUNIT_FILE}
  after_script:
  - coverage xml -i -o coverage.xml
  artifacts:
    when: always
    paths:
    - coverage.xml
    reports:
      junit:
      - junitxml.xml
      cobertura:
      - coverage.xml
  interruptible: true

sonarqube_check:
  extends: .base_check_sonarqube
  stage: sonarqube_check
  variables:
    SONAR_SOURCES: onetl
  rules:
  # do not run sonarcube check after pushing git tag, code was already linted
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success
  interruptible: true

build_and_deploy:
  extends: .base_pip_pkg_build_and_deploy_to_jfrog
  stage: artifactory
  variables:
    PYTHON_VERSION: '3.7'
  interruptible: true

# TODO: rewrite for versions before release
build_docs:
  image: $CI_REGISTRY/platform/python:${PYTHON_VERSION}
  variables:
    PYTHON_VERSION: '3.7'
  stage: build_docs
  before_script:
  - export VERSION=$(python setup.py --version)
  - echo "VERSION=$VERSION" >> deploy.env
  script:
  - pip install -r requirements.txt -r requirements-docs.txt
  - cd docs
  - make html
  - tar cvzf html-${VERSION}.tar.gz -C _build/html .
  - >
    if [ "$CI_COMMIT_TAG" != "" ];
    then cp html-${VERSION}.tar.gz html-latest.tar.gz;
    fi
  artifacts:
    paths:
    - docs/html-*.tar.gz
    reports:
      dotenv: deploy.env
  interruptible: true

publish_docs:
  extends: .base_rt_upload
  stage: artifactory
  variables:
    JFROG_RT_ARTIFACTS_PATTERN: docs/html-*.tar.gz
    JFROG_RT_UPLOAD_PATH: files/onetools/onetl/
  dependencies:
  - build_docs
  - devops_get_cicd_secrets
  interruptible: true

### --------------- DEPLOY --------------- ###
pages:
  extends: .base_pages_deploy_sphinx
  stage: deploy
  dependencies:
  - publish_docs
  variables:
    CICD_PAGES_ARTIFACTORY_DOCS_PATH: files/onetools/${CI_PROJECT_NAME}/docs
  interruptible: true

start_review_pip:
  stage: .post
  dependencies:
  - build_docs
  environment:
    name: review/pip/$CI_COMMIT_REF_SLUG
    url: ${CI_PAGES_URL}/${VERSION}/
    on_stop: stop_review_pip
  script:
  - echo "Start review"
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
  - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
    when: never
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success

stop_review_pip:
  extends: .base_rt_cli
  stage: .post
  script:
    # Remove artifacts for feature/bug branch
  - export CI_COMMIT_REF_SLUG=$(echo $CI_COMMIT_REF_SLUG | tr '-' '.')
  - jfrog rt delete files/onetools/onetl/docs/*+${CI_COMMIT_REF_SLUG}*
  - jfrog rt delete pypi-local/onetl/*+${CI_COMMIT_REF_SLUG}
  environment:
    name: review/pip/$CI_COMMIT_REF_SLUG
    action: stop
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
  - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
    when: never
  - if: $CI_COMMIT_TAG
    when: never
  - when: manual
    allow_failure: true

start_review_docker:
  stage: .post
  environment:
    name: review/docker/$CI_COMMIT_REF_SLUG
    on_stop: stop_review_docker
  script:
  - echo "Start review"
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
  - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
    when: never
  - if: $CI_COMMIT_TAG
    when: never
  - when: on_success

stop_review_docker:
  extends: .base_docker_cleaner
  stage: .post
  variables:
    DOCKER_IMAGE_TAGS: ${CI_COMMIT_REF_SLUG}
  environment:
    name: review/docker/$CI_COMMIT_REF_SLUG
    action: stop
  script:
  # parallel:matrix is not supported in on_stop jobs: https://gitlab.com/gitlab-org/gitlab/-/issues/332247
  # so calling .base_docker_cleaner script directly with multiple image names
  - DOCKER_IMAGE_NAME=${CI_PROJECT_PATH}
  - !reference [.base_docker_cleaner, script]
  - DOCKER_IMAGE_NAME=${CI_PROJECT_PATH}/webdav
  - !reference [.base_docker_cleaner, script]
  - DOCKER_IMAGE_NAME=${CI_PROJECT_PATH}/hive2
  - !reference [.base_docker_cleaner, script]
  - DOCKER_IMAGE_NAME=${CI_PROJECT_PATH}/postgres
  - !reference [.base_docker_cleaner, script]
  - DOCKER_IMAGE_NAME=${CI_PROJECT_PATH}/oracle
  - !reference [.base_docker_cleaner, script]
  rules:
  # environment is used to remove artifacts build in feature/ and bugfix/ branches only
  # dev and release packages are left intact
  - if: $CI_COMMIT_BRANCH =~ /^(dev|develop)$/
    when: never
  - if: $CI_COMMIT_TAG
    when: never
  - when: manual
    allow_failure: true
